import{extend as e,isArray as t,isMap as r,isIntegerKey as s,makeMap as n,isSymbol as o,hasOwn as c,isObject as a,hasChanged as i,capitalize as f,toRawType as u,def as l,isFunction as h,NOOP as d}from"@vue/shared";function warn(e,...t){console.warn(`[Vue warn] ${e}`,...t)}let p;const g=[];class EffectScope{constructor(e=false){this.active=true;this.effects=[];this.cleanups=[];if(!e&&p){this.parent=p;this.index=(p.scopes||(p.scopes=[])).push(this)-1}}run(e){if(this.active)try{this.on();return e()}finally{this.off()}else"production"!==process.env.NODE_ENV&&warn("cannot run an inactive effect scope.")}on(){if(this.active){g.push(this);p=this}}off(){if(this.active){g.pop();p=g[g.length-1]}}stop(e){if(this.active){this.effects.forEach((e=>e.stop()));this.cleanups.forEach((e=>e()));this.scopes&&this.scopes.forEach((e=>e.stop(true)));if(this.parent&&!e){const e=this.parent.scopes.pop();if(e&&e!==this){this.parent.scopes[this.index]=e;e.index=this.index}}this.active=false}}}function effectScope(e){return new EffectScope(e)}function recordEffectScope(e,t){t=t||p;t&&t.active&&t.effects.push(e)}function getCurrentScope(){return p}function onScopeDispose(e){p?p.cleanups.push(e):"production"!==process.env.NODE_ENV&&warn("onScopeDispose() is called when there is no active effect scope to be associated with.")}const createDep=e=>{const t=new Set(e);t.w=0;t.n=0;return t};const wasTracked=e=>(e.w&R)>0;const newTracked=e=>(e.n&R)>0;const initDepMarkers=({deps:e})=>{if(e.length)for(let t=0;t<e.length;t++)e[t].w|=R};const finalizeDepMarkers=e=>{const{deps:t}=e;if(t.length){let r=0;for(let s=0;s<t.length;s++){const n=t[s];wasTracked(n)&&!newTracked(n)?n.delete(e):t[r++]=n;n.w&=~R;n.n&=~R}t.length=r}};const _=new WeakMap;let v=0;let R=1;const w=30;const y=[];let E;const k=Symbol("production"!==process.env.NODE_ENV?"iterate":"");const m=Symbol("production"!==process.env.NODE_ENV?"Map key iterate":"");class ReactiveEffect{constructor(e,t=null,r){this.fn=e;this.scheduler=t;this.active=true;this.deps=[];recordEffectScope(this,r)}run(){if(!this.active)return this.fn();if(!y.includes(this))try{y.push(E=this);enableTracking();R=1<<++v;v<=w?initDepMarkers(this):cleanupEffect(this);return this.fn()}finally{v<=w&&finalizeDepMarkers(this);R=1<<--v;resetTracking();y.pop();const e=y.length;E=e>0?y[e-1]:void 0}}stop(){if(this.active){cleanupEffect(this);this.onStop&&this.onStop();this.active=false}}}function cleanupEffect(e){const{deps:t}=e;if(t.length){for(let r=0;r<t.length;r++)t[r].delete(e);t.length=0}}function effect(t,r){t.effect&&(t=t.effect.fn);const s=new ReactiveEffect(t);if(r){e(s,r);r.scope&&recordEffectScope(s,r.scope)}r&&r.lazy||s.run();const n=s.run.bind(s);n.effect=s;return n}function stop(e){e.effect.stop()}let N=true;const b=[];function pauseTracking(){b.push(N);N=false}function enableTracking(){b.push(N);N=true}function resetTracking(){const e=b.pop();N=void 0===e||e}function track(e,t,r){if(!isTracking())return;let s=_.get(e);s||_.set(e,s=new Map);let n=s.get(r);n||s.set(r,n=createDep());const o="production"!==process.env.NODE_ENV?{effect:E,target:e,type:t,key:r}:void 0;trackEffects(n,o)}function isTracking(){return N&&void 0!==E}function trackEffects(e,t){let r=false;if(v<=w){if(!newTracked(e)){e.n|=R;r=!wasTracked(e)}}else r=!e.has(E);if(r){e.add(E);E.deps.push(e);"production"!==process.env.NODE_ENV&&E.onTrack&&E.onTrack(Object.assign({effect:E},t))}}function trigger(e,n,o,c,a,i){const f=_.get(e);if(!f)return;let u=[];if("clear"===n)u=[...f.values()];else if("length"===o&&t(e))f.forEach(((e,t)=>{("length"===t||t>=c)&&u.push(e)}));else{void 0!==o&&u.push(f.get(o));switch(n){case"add":if(t(e))s(o)&&u.push(f.get("length"));else{u.push(f.get(k));r(e)&&u.push(f.get(m))}break;case"delete":if(!t(e)){u.push(f.get(k));r(e)&&u.push(f.get(m))}break;case"set":r(e)&&u.push(f.get(k));break}}const l="production"!==process.env.NODE_ENV?{target:e,type:n,key:o,newValue:c,oldValue:a,oldTarget:i}:void 0;if(1===u.length)u[0]&&("production"!==process.env.NODE_ENV?triggerEffects(u[0],l):triggerEffects(u[0]));else{const e=[];for(const t of u)t&&e.push(...t);"production"!==process.env.NODE_ENV?triggerEffects(createDep(e),l):triggerEffects(createDep(e))}}function triggerEffects(r,s){for(const n of t(r)?r:[...r])if(n!==E||n.allowRecurse){"production"!==process.env.NODE_ENV&&n.onTrigger&&n.onTrigger(e({effect:n},s));n.scheduler?n.scheduler():n.run()}}const V=n("__proto__,__v_isRef,__isVue");const O=new Set(Object.getOwnPropertyNames(Symbol).map((e=>Symbol[e])).filter(o));const S=createGetter();const D=createGetter(false,true);const I=createGetter(true);const T=createGetter(true,true);const M=createArrayInstrumentations();function createArrayInstrumentations(){const e={};["includes","indexOf","lastIndexOf"].forEach((t=>{e[t]=function(...e){const r=toRaw(this);for(let e=0,t=this.length;e<t;e++)track(r,"get",e+"");const s=r[t](...e);return-1===s||false===s?r[t](...e.map(toRaw)):s}}));["push","pop","shift","unshift","splice"].forEach((t=>{e[t]=function(...e){pauseTracking();const r=toRaw(this)[t].apply(this,e);resetTracking();return r}}));return e}function createGetter(e=false,r=false){return function get(n,i,f){if("__v_isReactive"===i)return!e;if("__v_isReadonly"===i)return e;if("__v_raw"===i&&f===(e?r?U:Q:r?L:J).get(n))return n;const u=t(n);if(!e&&u&&c(M,i))return Reflect.get(M,i,f);const l=Reflect.get(n,i,f);if(o(i)?O.has(i):V(i))return l;e||track(n,"get",i);if(r)return l;if(isRef(l)){const e=!u||!s(i);return e?l.value:l}return a(l)?e?readonly(l):reactive(l):l}}const $=createSetter();const x=createSetter(true);function createSetter(e=false){return function set(r,n,o,a){let f=r[n];if(!e&&!isReadonly(o)){o=toRaw(o);f=toRaw(f);if(!t(r)&&isRef(f)&&!isRef(o)){f.value=o;return true}}const u=t(r)&&s(n)?Number(n)<r.length:c(r,n);const l=Reflect.set(r,n,o,a);r===toRaw(a)&&(u?i(o,f)&&trigger(r,"set",n,o,f):trigger(r,"add",n,o));return l}}function deleteProperty(e,t){const r=c(e,t);const s=e[t];const n=Reflect.deleteProperty(e,t);n&&r&&trigger(e,"delete",t,void 0,s);return n}function has(e,t){const r=Reflect.has(e,t);o(t)&&O.has(t)||track(e,"has",t);return r}function ownKeys(e){track(e,"iterate",t(e)?"length":k);return Reflect.ownKeys(e)}const j={get:S,set:$,deleteProperty:deleteProperty,has:has,ownKeys:ownKeys};const P={get:I,set(e,t){"production"!==process.env.NODE_ENV&&console.warn(`Set operation on key "${String(t)}" failed: target is readonly.`,e);return true},deleteProperty(e,t){"production"!==process.env.NODE_ENV&&console.warn(`Delete operation on key "${String(t)}" failed: target is readonly.`,e);return true}};const z=e({},j,{get:D,set:x});const C=e({},P,{get:T});const toShallow=e=>e;const getProto=e=>Reflect.getPrototypeOf(e);function get$1(e,t,r=false,s=false){e=e.__v_raw;const n=toRaw(e);const o=toRaw(t);t!==o&&!r&&track(n,"get",t);!r&&track(n,"get",o);const{has:c}=getProto(n);const a=s?toShallow:r?toReadonly:toReactive;if(c.call(n,t))return a(e.get(t));if(c.call(n,o))return a(e.get(o));e!==n&&e.get(t)}function has$1(e,t=false){const r=this.__v_raw;const s=toRaw(r);const n=toRaw(e);e!==n&&!t&&track(s,"has",e);!t&&track(s,"has",n);return e===n?r.has(e):r.has(e)||r.has(n)}function size(e,t=false){e=e.__v_raw;!t&&track(toRaw(e),"iterate",k);return Reflect.get(e,"size",e)}function add(e){e=toRaw(e);const t=toRaw(this);const r=getProto(t);const s=r.has.call(t,e);if(!s){t.add(e);trigger(t,"add",e,e)}return this}function set$1(e,t){t=toRaw(t);const r=toRaw(this);const{has:s,get:n}=getProto(r);let o=s.call(r,e);if(o)"production"!==process.env.NODE_ENV&&checkIdentityKeys(r,s,e);else{e=toRaw(e);o=s.call(r,e)}const c=n.call(r,e);r.set(e,t);o?i(t,c)&&trigger(r,"set",e,t,c):trigger(r,"add",e,t);return this}function deleteEntry(e){const t=toRaw(this);const{has:r,get:s}=getProto(t);let n=r.call(t,e);if(n)"production"!==process.env.NODE_ENV&&checkIdentityKeys(t,r,e);else{e=toRaw(e);n=r.call(t,e)}const o=s?s.call(t,e):void 0;const c=t.delete(e);n&&trigger(t,"delete",e,void 0,o);return c}function clear(){const e=toRaw(this);const t=0!==e.size;const s="production"!==process.env.NODE_ENV?r(e)?new Map(e):new Set(e):void 0;const n=e.clear();t&&trigger(e,"clear",void 0,void 0,s);return n}function createForEach(e,t){return function forEach(r,s){const n=this;const o=n.__v_raw;const c=toRaw(o);const a=t?toShallow:e?toReadonly:toReactive;!e&&track(c,"iterate",k);return o.forEach(((e,t)=>r.call(s,a(e),a(t),n)))}}function createIterableMethod(e,t,s){return function(...n){const o=this.__v_raw;const c=toRaw(o);const a=r(c);const i="entries"===e||e===Symbol.iterator&&a;const f="keys"===e&&a;const u=o[e](...n);const l=s?toShallow:t?toReadonly:toReactive;!t&&track(c,"iterate",f?m:k);return{next(){const{value:e,done:t}=u.next();return t?{value:e,done:t}:{value:i?[l(e[0]),l(e[1])]:l(e),done:t}},[Symbol.iterator](){return this}}}}function createReadonlyMethod(e){return function(...t){if("production"!==process.env.NODE_ENV){const r=t[0]?`on key "${t[0]}" `:"";console.warn(`${f(e)} operation ${r}failed: target is readonly.`,toRaw(this))}return"delete"!==e&&this}}function createInstrumentations(){const e={get(e){return get$1(this,e)},get size(){return size(this)},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(false,false)};const t={get(e){return get$1(this,e,false,true)},get size(){return size(this)},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(false,true)};const r={get(e){return get$1(this,e,true)},get size(){return size(this,true)},has(e){return has$1.call(this,e,true)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(true,false)};const s={get(e){return get$1(this,e,true,true)},get size(){return size(this,true)},has(e){return has$1.call(this,e,true)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(true,true)};const n=["keys","values","entries",Symbol.iterator];n.forEach((n=>{e[n]=createIterableMethod(n,false,false);r[n]=createIterableMethod(n,true,false);t[n]=createIterableMethod(n,false,true);s[n]=createIterableMethod(n,true,true)}));return[e,r,t,s]}const[G,W,K,A]=createInstrumentations();function createInstrumentationGetter(e,t){const r=t?e?A:K:e?W:G;return(t,s,n)=>"__v_isReactive"===s?!e:"__v_isReadonly"===s?e:"__v_raw"===s?t:Reflect.get(c(r,s)&&s in t?r:t,s,n)}const F={get:createInstrumentationGetter(false,false)};const B={get:createInstrumentationGetter(false,true)};const q={get:createInstrumentationGetter(true,false)};const H={get:createInstrumentationGetter(true,true)};function checkIdentityKeys(e,t,r){const s=toRaw(r);if(s!==r&&t.call(e,s)){const t=u(e);console.warn(`Reactive ${t} contains both the raw and reactive versions of the same object${"Map"===t?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}const J=new WeakMap;const L=new WeakMap;const Q=new WeakMap;const U=new WeakMap;function targetTypeMap(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function getTargetType(e){return e.__v_skip||!Object.isExtensible(e)?0:targetTypeMap(u(e))}function reactive(e){return e&&e.__v_isReadonly?e:createReactiveObject(e,false,j,F,J)}function shallowReactive(e){return createReactiveObject(e,false,z,B,L)}function readonly(e){return createReactiveObject(e,true,P,q,Q)}function shallowReadonly(e){return createReactiveObject(e,true,C,H,U)}function createReactiveObject(e,t,r,s,n){if(!a(e)){"production"!==process.env.NODE_ENV&&console.warn(`value cannot be made reactive: ${String(e)}`);return e}if(e.__v_raw&&!(t&&e.__v_isReactive))return e;const o=n.get(e);if(o)return o;const c=getTargetType(e);if(0===c)return e;const i=new Proxy(e,2===c?s:r);n.set(e,i);return i}function isReactive(e){return isReadonly(e)?isReactive(e.__v_raw):!!(e&&e.__v_isReactive)}function isReadonly(e){return!!(e&&e.__v_isReadonly)}function isProxy(e){return isReactive(e)||isReadonly(e)}function toRaw(e){const t=e&&e.__v_raw;return t?toRaw(t):e}function markRaw(e){l(e,"__v_skip",true);return e}const toReactive=e=>a(e)?reactive(e):e;const toReadonly=e=>a(e)?readonly(e):e;function trackRefValue(e){if(isTracking()){e=toRaw(e);e.dep||(e.dep=createDep());"production"!==process.env.NODE_ENV?trackEffects(e.dep,{target:e,type:"get",key:"value"}):trackEffects(e.dep)}}function triggerRefValue(e,t){e=toRaw(e);e.dep&&("production"!==process.env.NODE_ENV?triggerEffects(e.dep,{target:e,type:"set",key:"value",newValue:t}):triggerEffects(e.dep))}function isRef(e){return Boolean(e&&true===e.__v_isRef)}function ref(e){return createRef(e,false)}function shallowRef(e){return createRef(e,true)}function createRef(e,t){return isRef(e)?e:new RefImpl(e,t)}class RefImpl{constructor(e,t){this._shallow=t;this.dep=void 0;this.__v_isRef=true;this._rawValue=t?e:toRaw(e);this._value=t?e:toReactive(e)}get value(){trackRefValue(this);return this._value}set value(e){e=this._shallow?e:toRaw(e);if(i(e,this._rawValue)){this._rawValue=e;this._value=this._shallow?e:toReactive(e);triggerRefValue(this,e)}}}function triggerRef(e){triggerRefValue(e,"production"!==process.env.NODE_ENV?e.value:void 0)}function unref(e){return isRef(e)?e.value:e}const X={get:(e,t,r)=>unref(Reflect.get(e,t,r)),set:(e,t,r,s)=>{const n=e[t];if(isRef(n)&&!isRef(r)){n.value=r;return true}return Reflect.set(e,t,r,s)}};function proxyRefs(e){return isReactive(e)?e:new Proxy(e,X)}class CustomRefImpl{constructor(e){this.dep=void 0;this.__v_isRef=true;const{get:t,set:r}=e((()=>trackRefValue(this)),(()=>triggerRefValue(this)));this._get=t;this._set=r}get value(){return this._get()}set value(e){this._set(e)}}function customRef(e){return new CustomRefImpl(e)}function toRefs(e){"production"===process.env.NODE_ENV||isProxy(e)||console.warn("toRefs() expects a reactive object but received a plain one.");const r=t(e)?new Array(e.length):{};for(const t in e)r[t]=toRef(e,t);return r}class ObjectRefImpl{constructor(e,t,r){this._object=e;this._key=t;this._defaultValue=r;this.__v_isRef=true}get value(){const e=this._object[this._key];return void 0===e?this._defaultValue:e}set value(e){this._object[this._key]=e}}function toRef(e,t,r){const s=e[t];return isRef(s)?s:new ObjectRefImpl(e,t,r)}class ComputedRefImpl{constructor(e,t,r){this._setter=t;this.dep=void 0;this._dirty=true;this.__v_isRef=true;this.effect=new ReactiveEffect(e,(()=>{if(!this._dirty){this._dirty=true;triggerRefValue(this)}}));this.__v_isReadonly=r}get value(){const e=toRaw(this);trackRefValue(e);if(e._dirty){e._dirty=false;e._value=e.effect.run()}return e._value}set value(e){this._setter(e)}}function computed(e,t){let r;let s;const n=h(e);if(n){r=e;s="production"!==process.env.NODE_ENV?()=>{console.warn("Write operation failed: computed value is readonly")}:d}else{r=e.get;s=e.set}const o=new ComputedRefImpl(r,s,n||!s);if("production"!==process.env.NODE_ENV&&t){o.effect.onTrack=t.onTrack;o.effect.onTrigger=t.onTrigger}return o}var Y;const Z=Promise.resolve();const ee=[];let te=false;const scheduler=e=>{ee.push(e);if(!te){te=true;Z.then(flush)}};const flush=()=>{for(let e=0;e<ee.length;e++)ee[e]();ee.length=0;te=false};class DeferredComputedRefImpl{constructor(e){this.dep=void 0;this._dirty=true;this.__v_isRef=true;this[Y]=true;let t;let r=false;let s=false;this.effect=new ReactiveEffect(e,(e=>{if(this.dep){if(e){t=this._value;r=true}else if(!s){const e=r?t:this._value;s=true;r=false;scheduler((()=>{this.effect.active&&this._get()!==e&&triggerRefValue(this);s=false}))}for(const e of this.dep)e.computed&&e.scheduler(true)}this._dirty=true}));this.effect.computed=true}_get(){if(this._dirty){this._dirty=false;return this._value=this.effect.run()}return this._value}get value(){trackRefValue(this);return toRaw(this)._get()}}Y="__v_isReadonly";function deferredComputed(e){return new DeferredComputedRefImpl(e)}export{EffectScope,k as ITERATE_KEY,ReactiveEffect,computed,customRef,deferredComputed,effect,effectScope,enableTracking,getCurrentScope,isProxy,isReactive,isReadonly,isRef,markRaw,onScopeDispose,pauseTracking,proxyRefs,reactive,readonly,ref,resetTracking,shallowReactive,shallowReadonly,shallowRef,stop,toRaw,toRef,toRefs,track,trigger,triggerRef,unref};

